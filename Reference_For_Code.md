# Reference For Code Implementation
## AI use

### 1. Use AI to find free time
**Prompt**
Prompt: If I want to find a period of free time, how do I find it? Suppose a list contains the start_time and end_time of events. The time between start_time and end_time is the busy time, and there are multiple events

**Model**
Model: Claude 3.5 Sonnet & ChatGPT

**Response**
```
class TimeSlot {
    constructor(start, end) {
        this.start = new Date(start);
        this.end = new Date(end);
    }
}

function findFreeTimeSlots(events, searchStart, searchEnd) {
    // Convert search range to Date objects
    const rangeStart = new Date(searchStart);
    const rangeEnd = new Date(searchEnd);
    
    // Convert all events to TimeSlot objects and sort them
    const busySlots = events
        .map(event => new TimeSlot(event.start_time, event.end_time))
        .sort((a, b) => a.start - b.start);
    
    // Merge overlapping time slots
    const mergedBusySlots = [];
    for (const slot of busySlots) {
        if (mergedBusySlots.length === 0) {
            mergedBusySlots.push(slot);
            continue;
        }
        
        const lastSlot = mergedBusySlots[mergedBusySlots.length - 1];
        if (slot.start <= lastSlot.end) {
            // Overlapping, update end time
            lastSlot.end = new Date(Math.max(lastSlot.end, slot.end));
        } else {
            // No overlap, add new slot
            mergedBusySlots.push(slot);
        }
    }
    
    // Find free time slots
    const freeSlots = [];
    let currentTime = rangeStart;
    
    for (const busySlot of mergedBusySlots) {
        // If current time is before busy slot start, this is free time
        if (currentTime < busySlot.start) {
            freeSlots.push(new TimeSlot(currentTime, busySlot.start));
        }
        currentTime = busySlot.end;
    }
    
    // Check for free time after last busy slot until search end time
    if (currentTime < rangeEnd) {
        freeSlots.push(new TimeSlot(currentTime, rangeEnd));
    }
    
    return freeSlots;
}

// Usage example
const events = [
    {
        start_time: "2024-02-16T09:00:00Z",
        end_time: "2024-02-16T10:30:00Z"
    },
    {
        start_time: "2024-02-16T10:00:00Z",
        end_time: "2024-02-16T11:00:00Z"
    },
    {
        start_time: "2024-02-16T14:00:00Z",
        end_time: "2024-02-16T15:00:00Z"
    }
];

const searchStart = "2024-02-16T08:00:00Z";
const searchEnd = "2024-02-16T18:00:00Z";

const freeTimeSlots = findFreeTimeSlots(events, searchStart, searchEnd);

// Print results
freeTimeSlots.forEach(slot => {
    console.log(`Free time: ${slot.start.toISOString()} - ${slot.end.toISOString()}`);
});

// Optional: Add a function to filter by minimum duration
function findFreeTimeSlotsWithMinDuration(events, searchStart, searchEnd, minDurationMinutes) {
    const allFreeSlots = findFreeTimeSlots(events, searchStart, searchEnd);
    
    return allFreeSlots.filter(slot => {
        const durationMinutes = (slot.end - slot.start) / (1000 * 60);
        return durationMinutes >= minDurationMinutes;
    });
}

// Example with minimum duration
const freeSlotsWith30MinMin = findFreeTimeSlotsWithMinDuration(
    events,
    searchStart,
    searchEnd,
    30 // minimum 30 minutes
);
```

**Use**
Since it did not provide expected results, I continued to ask it to imrpove the code, and spent a lot of time in testing this feature. Current code was generated by ChatGPT after multiple times. The code works now but is very complicated.

### 2. Use AI to check time conflict
**Prompt**
Prompt: how to compare an event's time (start, end) overlaps with another event (by checking a list of events)
**Model**
Model: Claude 3.5 Sonnet
**Response**
To check if an event overlaps with any other events in a list, you need to compare the start and end times. Two events overlap if one starts before the other ends and ends after the other starts.
Here's how you can implement this in JavaScript:
```
function isEventOverlapping(newEvent, existingEvents) {
  return existingEvents.some(existingEvent => {
    // Two events overlap if:
    // 1. newEvent starts before existingEvent ends AND
    // 2. newEvent ends after existingEvent starts
    return newEvent.start < existingEvent.end && newEvent.end > existingEvent.start;
  });
}

// Example usage:
const events = [
  { id: 1, start: new Date('2024-02-16T09:00:00Z'), end: new Date('2024-02-16T10:00:00Z') },
  { id: 2, start: new Date('2024-02-16T14:00:00Z'), end: new Date('2024-02-16T15:30:00Z') }
];

const newEvent = {
  start: new Date('2024-02-16T09:30:00Z'),
  end: new Date('2024-02-16T11:00:00Z')
};

if (isEventOverlapping(newEvent, events)) {
  console.log('This event overlaps with an existing event!');
} else {
  console.log('This event does not overlap with any existing events.');
}
```
If you're working with strings instead of Date objects, you'll need to convert them first:
```
function isEventOverlapping(newEvent, existingEvents) {
  const newStart = new Date(newEvent.start);
  const newEnd = new Date(newEvent.end);

  return existingEvents.some(existingEvent => {
    const existingStart = new Date(existingEvent.start);
    const existingEnd = new Date(existingEvent.end);

    return newStart < existingEnd && newEnd > existingStart;
  });
}
```
The time complexity of this solution is O(n) where n is the number of existing events, as we need to check against each one until we find an overlap or exhaust the list.

**Use**
Used it as reference

### 3. Use AI to allocate sessions
**Prompt**
Prompt: How to allocate a total time scatteredly among a list of free slots?

**Model**
Model: ChatGPT 4o

**Response**
```
import TimeSlot from './TimeSlot.js'; // Import the TimeSlot class

function allocateTimeSmartly(total_time, free_slots, slots_per_day = 2) {
    let allocated_slots = [];
    let slots_by_day = {};
    let used_days = new Set();
    let used_slots = new Set(); // Tracks used slot objects

    // Step 1: Group slots by day (YYYY-MM-DD as key)
    for (let slot of free_slots) {
        let dateKey = slot.start.toISOString().split("T")[0]; // Extract "YYYY-MM-DD"
        if (!slots_by_day[dateKey]) {
            slots_by_day[dateKey] = [];
        }
        slots_by_day[dateKey].push(slot);
    }

    // Step 2: Allocate time up to `slots_per_day` per day
    for (let date in slots_by_day) {
        if (total_time <= 0) break; // Stop if all time is allocated

        let slots = slots_by_day[date];
        let allocated_count = 0;

        for (let i = 0; i < slots.length; i++) {
            if (allocated_count >= slots_per_day || total_time <= 0) break; // Limit to 2 per day

            let slot = slots[i];
            let slot_duration = (slot.end - slot.start) / (1000 * 60); // Convert to minutes
            let allocation_time = Math.min(total_time, slot_duration); // Allocate within slot's capacity

            let allocated_start = slot.start;
            let allocated_end = new Date(slot.start.getTime() + allocation_time * 60 * 1000);

            allocated_slots.push(new TimeSlot(allocated_start, allocated_end));

            total_time -= allocation_time; // Reduce remaining time
            allocated_count++; // Track allocated slots per day
            used_days.add(date);
            used_slots.add(slot.start.toISOString()); // Mark this slot as used
        }
    }

    // Step 3: If all days are used and time is left, allocate freely from unused slots
    if (total_time > 0) {
        for (let slot of free_slots) {
            if (total_time <= 0) break; // Stop when done
            if (used_slots.has(slot.start.toISOString())) continue; // Skip slots already used

            let slot_duration = (slot.end - slot.start) / (1000 * 60); // Convert to minutes
            let allocation_time = Math.min(total_time, slot_duration);

            let allocated_start = slot.start;
            let allocated_end = new Date(slot.start.getTime() + allocation_time * 60 * 1000);

            allocated_slots.push(new TimeSlot(allocated_start, allocated_end));

            total_time -= allocation_time;
        }
    }

    return allocated_slots;
}

```

**Use**
I asked the ChatGPT for a few times to get it works. The code implementation for this part is mostly generated from ChatGPT

### 4. Use AI to exclude block times
**Prompt**
Prompt: How to remove block_slots defined in another list from free_slots (the start time of block_slots is not necessarily equal to the time of a free slot)

**Model**
Model: ChatGPT 4o

**Response**
```
import TimeSlot from "./TimeSlot.js"; // Import TimeSlot class

function removeBlockedSlots(free_slots, block_slots) {
    let updated_free_slots = [];

    // Sort both lists by start time
    free_slots.sort((a, b) => a.start - b.start);
    block_slots.sort((a, b) => a.start - b.start);

    for (let free of free_slots) {
        let new_slots = [free]; // Start with the original free slot

        for (let block of block_slots) {
            let temp_slots = [];

            for (let slot of new_slots) {
                // Check for overlap
                if (block.end <= slot.start || block.start >= slot.end) {
                    temp_slots.push(slot); // No overlap, keep it
                } else {
                    // Partial or full overlap
                    if (block.start > slot.start) {
                        temp_slots.push(new TimeSlot(slot.start, block.start)); // Before blocked slot
                    }
                    if (block.end < slot.end) {
                        temp_slots.push(new TimeSlot(block.end, slot.end)); // After blocked slot
                    }
                }
            }

            new_slots = temp_slots; // Update slots after processing this block
        }

        updated_free_slots.push(...new_slots);
    }

    return updated_free_slots;
}

// âœ… Example Usage
let free_slots = [
    new TimeSlot("2025-02-11T09:00:00Z", "2025-02-11T11:00:00Z"),
    new TimeSlot("2025-02-11T13:00:00Z", "2025-02-11T15:00:00Z")
];

let block_slots = [
    new TimeSlot("2025-02-11T09:30:00Z", "2025-02-11T10:00:00Z"), // Partial overlap in first slot
    new TimeSlot("2025-02-11T14:00:00Z", "2025-02-11T14:30:00Z")  // Partial overlap in second slot
];

console.log(removeBlockedSlots(free_slots, block_slots));

```

**Use**
Used it directly, and modified it a little bit to make it work


### 5. Use AI to figure out the type of an object for JSDoc
**Prompt**
Prompt: How do I describe the types of exist events
```
exist_events.push({
    "type": "",
    "eventType": "normal",
    "details": {
        "id": "2",
        "summary": "March Social Event",
        "start": { "dateTime": "2025-02-28T15:00:00Z" },
        "end": { "dateTime": "2025-02-28T16:00:00Z" }
        }
    }
);

* [{
*     "type": "",
*     "eventType": "normal", // "normal", "studysession", "assignment"
*     "details": {
*         "id": "1",
*         "summary": "Dance club meeting",
*         "start": { "dateTime": "2025-03-11T10:00:00Z" },
*         "end": { "dateTime": "2025-03-11T11:00:00Z" }
*         }
*  }, ...]
```

**Model**
Model: ChatGPT 4o

**Response** 
1. 
```
/**
 * @typedef {Object} EventDetails
 * @property {string} id - Event ID
 * @property {string} summary - Event summary
 * @property {Object} start - Event start time
 * @property {string} start.dateTime - Start time in ISO 8601 format
 * @property {Object} end - Event end time
 * @property {string} end.dateTime - End time in ISO 8601 format
 */

/**
 * @typedef {Object} Event
 * @property {string} type - Event type (empty string if undefined)
 * @property {string} eventType - Specific event category (e.g., "normal")
 * @property {EventDetails} details - Event details
 */

/**
 * List of existing events
 * @type {Array<Event>}
 */
const exist_events = [];
```
2. 
```
/**
 * List of existing events
 * @type {Array<{ type: string, eventType: string, details: { id: string, summary: string, start: { dateTime: string }, end: { dateTime: string } } }>}
 */
const exist_events = [];

```
**Use**
Used solution 1 but there were errors when generating JSDoc, so I asked the ChatGpt to debug. Current format was generated by it as well.

### 6. Use AI to debug my code when running
**Prompt**
The error messages displayed during running the code (node main.js)

**Model**
Model: ChatGPT 4o

**Response**
It explained the reasons of errors and suggesed modification.

**Use**
Based on the explanation, modified the code.

### 7. Use AI to generate a template for OOPDoc.md
**Prompt**
"Demonstrate the application of object oriented programming in your code

    Provide at least one example in your code of the application of each one of the OOP pillars (Abstraction, Encapsulation, Inheritance and Polymorphism). 
    Show at least one example of your code demonstrating each one of the SOLID Principles.
    Provide at least three examples of application of design patterns in your code (e.g. Singleton, Builder, Factory, etc).
    Explain why these examples are a good application of OOP and:
        provide an hypothetical example (not in your code) that would break each concept.
    Write all of these in a MarkDown file with code blocks and the supporting code"
Please give me a markdown file format according to this requirement

**Model**
Model: ChatGPT 4o

**Use**
Used the template and modifed.



